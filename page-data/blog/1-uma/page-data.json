{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/1-uma","result":{"data":{"markdownRemark":{"html":"<p>I've been using <a href=\"https://kantarainitiative.org/confluence/display/uma/Home\">UMA 2.0</a> as a way to protect a healthcare-based HTTP API where it solves the main issue I had with OAuth: <strong>the resource owner and the user of the resource are 2 separate entities</strong>.\nUMA also defines the concept of UMA resources which simplifies the permissions management of individual resources with access levels (UMA scopes).</p>\n<p>The main reason to use UMA, like OAuth, is to simplify some of the access control work since a lot of the token management and lifecycle gets outsourced to a third party server but it has some drawbacks which need to be considered.</p>\n<h2>UMA 2.0</h2>\n<p>UMA defines 2 main components which interact together: the authorization server (<a href=\"https://www.keycloak.org/\">Keycloak</a> in my case) which handles all of the token management and lifecycle and the resource server, which is the backend that requires protection.</p>\n<p>The resource server communicates with the authorization server to emit tokens, validate them, create corresponding resources, etc.</p>\n<h4>UMA flow</h4>\n<p>From the perspective of the user accessing a resource the following flow needs to be followed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">requesting                        authorization resource resource\n  party   client                      server     server    owner\n    |        |                           |          |         |\n    |        |                           |Set policy|         |\n    |        |                           |conditions (anytime)|\n    |        |                           |&lt;- - - - - - - - - -|\n    |        |Resource request (no access token)    |         |\n    |        |--- (1) -----------------------------&gt;|         |\n    |        |                           |Request permissions |\n    |        |                           |&lt;-- (2) --|         |\n    |        |                           |Permissions ticket  |\n    |        |                           |--- (2) -&gt;|         |\n    |        |401 response with: new permission     |         |\n    |        |ticket, AS location        |          |         |\n    |        |&lt;-- (3) ------------------------------|         |\n    |        |Authz request with ticket, |          |         |\n    |        |claim token (push claims)  |          |         |\n    |        |--- (4) ------------------&gt;|          |         |\n    |        |                      +----|Authz     |         |\n    |        |                      +---&gt;|assessment|         |\n    |        |Authz response with access |          |         |\n    |        |token (RPT) and PCT        |          |         |\n    |        |&lt;-- (4) -------------------|          |         |\n    |        |Resource request with access token    |         |\n    |        |(RPT)                      |          |         |\n    |        |--- (5) -----------------------------&gt;|         |\n    |        |                           |Introspect RPT token|\n    |        |                           |&lt;-- (5) --|         |\n    |        |                           |Token metadata      |\n    |        |                           |--- (5) -&gt;|         |\n    |        |Protected resource         |          |         |\n    |        |&lt;-- (5) ------------------------------|         |</code></pre></div>\n<p>a. Steps 1-3. The user makes a request for the resource without using any tokens. The resource server must return a permission ticket which corresponds to the resources being requested. The resource server communicates with the authorization server to emit this ticket.</p>\n<p>b. Step 4. The user exchanges with the authorization server the permission ticket from the previous step and a login token (which can be an OpenID Connect token) for an RPT token. In this step the authorization server checks the permissions that are set for the user.</p>\n<p>c. Step 5. The user makes the same request as from step 1 including the RPT token and obtains the resources. The resource server must introspect the RPT token to obtain the permissions, either by decoding the it as a JWS token (is supported by the authorization server) or by introspecting it.</p>\n<h4>Drawbacks</h4>\n<p>As can be seen in the user's flow, a full request flow will make 2 requests to the resource server: once to obtain the permissions ticket and again to actually obtain the resource. This performance degradation can be prohibitive when the resource server endpoint must consider a lot of resources (such as in a search endpoint). Whis double request can be mitigated either by reusing the RPT token or, in the case of Keycloak, by pre-emptively requesting and RPT token with all of the user's permissions set.</p>\n<p>There are also additional requests that the user and resource server need to make with the authorization server in order to emit a permissions ticket and obtain an RPT token.</p>","frontmatter":{"date":"2020-07-20","slug":"/blog/1-uma","title":"Using UMA for protecting HTTP APIs"}}},"pageContext":{"slug":"/blog/1-uma"}}}